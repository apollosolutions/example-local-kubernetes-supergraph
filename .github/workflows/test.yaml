---
name: Test Apollo Supergraph

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

jobs:
  test-subgraphs:
    name: Test Subgraphs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: subgraphs/package-lock.json

      - name: Install dependencies
        run: |
          cd subgraphs
          npm ci

      - name: Test subgraphs validation
        run: |
          cd subgraphs
          if npm run | grep -q "validate"; then
            npm run validate
          else
            echo "No validate script found, skipping"
          fi

  test-supergraph-composition:
    name: Test Supergraph Composition
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Rover CLI
        run: |
          curl -sSL https://rover.apollo.dev/nix/latest | sh
          echo "$HOME/.rover/bin" >> $GITHUB_PATH

      - name: Test supergraph composition
        run: |
          cd router
          ./compose.sh

          # Verify the supergraph file was created
          if [ ! -f "supergraph.graphql" ]; then
            echo "‚ùå Supergraph composition failed - file not created"
            exit 1
          fi

          # Verify the supergraph contains expected content
          if ! grep -q "join__Graph" supergraph.graphql; then
            echo "‚ùå Supergraph composition failed - missing join__Graph"
            exit 1
          fi

          echo "‚úÖ Supergraph composition successful"

  test-docker-builds:
    name: Test Docker Builds
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build subgraphs Docker image
        run: |
          cd subgraphs
          docker build -t subgraphs:test .

          # Verify the image was created
          if ! docker images | grep -q "subgraphs.*test"; then
            echo "‚ùå Docker build failed for subgraphs"
            exit 1
          fi

          echo "‚úÖ Subgraphs Docker build successful"

  test-scripts:
    name: Test Helper Scripts
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Test script syntax
        run: |
          # Test that all scripts have valid syntax
          for script in *.sh; do
            if [ -f "$script" ]; then
              echo "Testing syntax for $script"
              bash -n "$script" || exit 1
            fi
          done

          # Test scripts in scripts directory
          if [ -d "scripts" ]; then
            for script in scripts/*.sh; do
              if [ -f "$script" ]; then
                echo "Testing syntax for $script"
                bash -n "$script" || exit 1
              fi
            done
          fi

          echo "‚úÖ All scripts have valid syntax"

      - name: Test script help options
        run: |
          # Test that scripts with help options work
          ./run-k8s.sh --help || exit 1
          ./cleanup-k8s.sh --help || exit 1
          ./kill-minikube.sh --help || exit 1
          ./setup-minikube.sh --help || exit 1
          ./setup-env.sh --help || exit 1
          ./test-router.sh --help || exit 1

          echo "‚úÖ All script help options working"

      - name: Test new test utilities
        run: |
          # Test that test utilities can be sourced without errors
          echo "Testing test utilities..."
          
          # Source test utilities and test basic functions
          source scripts/test-utils.sh
          
          # Test that functions are available
          if ! type test_router_health > /dev/null 2>&1; then
            echo "‚ùå test_router_health function not found"
            exit 1
          fi
          
          if ! type test_search_products > /dev/null 2>&1; then
            echo "‚ùå test_search_products function not found"
            exit 1
          fi
          
          if ! type test_router_comprehensive > /dev/null 2>&1; then
            echo "‚ùå test_router_comprehensive function not found"
            exit 1
          fi
          
          echo "‚úÖ Test utilities functions available"
          
          # Test that test utilities can be run directly
          echo "Testing test utilities execution..."
          
          # Test that the script can be run with --help (should show usage)
          if ! bash scripts/test-utils.sh --help 2>&1 | grep -q "Available tests"; then
            echo "‚ùå test-utils.sh --help not working correctly"
            exit 1
          fi
          
          echo "‚úÖ Test utilities execution working"

      - name: Test script organization
        run: |
          echo "üîç Dynamically discovering scripts..."
          
          # Discover user-facing scripts in root directory
          echo "üìÅ Checking user-facing scripts in root directory..."
          user_scripts=($(find . -maxdepth 1 -name "*.sh" -type f -exec basename {} \; | grep -v "^\.$"))
          
          if [ ${#user_scripts[@]} -eq 0 ]; then
            echo "‚ùå No user-facing scripts found in root directory"
            exit 1
          fi
          
          echo "‚úÖ Found ${#user_scripts[@]} user-facing scripts:"
          for script in "${user_scripts[@]}"; do
            echo "  - $script"
          done
          
          # Discover internal scripts in scripts directory
          echo "üìÅ Checking internal scripts in scripts directory..."
          if [ ! -d "scripts" ]; then
            echo "‚ùå scripts directory not found"
            exit 1
          fi
          
          internal_scripts=($(find scripts -name "*.sh" -type f -exec basename {} \;))
          
          if [ ${#internal_scripts[@]} -eq 0 ]; then
            echo "‚ùå No internal scripts found in scripts directory"
            exit 1
          fi
          
          echo "‚úÖ Found ${#internal_scripts[@]} internal scripts:"
          for script in "${internal_scripts[@]}"; do
            echo "  - scripts/$script"
          done
          
          echo "‚úÖ Script organization is correct"
          
          # Test that scripts are using test utilities (no duplication)
          echo "Testing for script duplication..."
          
          # Check all scripts for hardcoded curl commands that should use test utilities
          echo "üîç Checking for hardcoded curl commands in scripts..."
          
          # Check user-facing scripts
          for script in "${user_scripts[@]}"; do
            if grep -q "curl.*localhost:4000" "$script"; then
              echo "‚ùå $script contains hardcoded curl commands for router testing"
              echo "   Should use test utilities instead"
              exit 1
            fi
          done
          
          # Check internal scripts (but allow some curl usage in test-utils.sh itself)
          for script in "${internal_scripts[@]}"; do
            if [ "$script" != "test-utils.sh" ] && grep -q "curl.*localhost:4000.*health" "scripts/$script"; then
              echo "‚ùå scripts/$script contains hardcoded curl commands for health checks"
              echo "   Should use test utilities instead"
              exit 1
            fi
          done
          
          echo "‚úÖ No duplication found - scripts using test utilities correctly"
          
          # Test that test utilities contain expected functions
          echo "Testing test utilities content..."
          
          # Check that test-utils.sh exists
          if [ ! -f "scripts/test-utils.sh" ]; then
            echo "‚ùå test-utils.sh not found in scripts directory"
            exit 1
          fi
          
          # Discover test functions dynamically
          echo "üîç Discovering test functions in test-utils.sh..."
          test_functions=($(grep -E "^test_[a-zA-Z_]+\(\)" scripts/test-utils.sh | sed 's/() {.*//' | sort))
          
          if [ ${#test_functions[@]} -eq 0 ]; then
            echo "‚ùå No test functions found in test-utils.sh"
            exit 1
          fi
          
          echo "‚úÖ Found ${#test_functions[@]} test functions:"
          for func in "${test_functions[@]}"; do
            echo "  - $func"
          done
          
          # Check for essential test functions
          essential_functions=("test_router_health" "test_search_products")
          for func in "${essential_functions[@]}"; do
            if [[ ! " ${test_functions[@]} " =~ " ${func} " ]]; then
              echo "‚ùå Essential test function not found: $func"
              exit 1
            fi
          done
          
          echo "‚úÖ Test utilities contain essential functions"
          
          # Test that test-router.sh works correctly
          echo "Testing test-router.sh functionality..."
          
          # Check that test-router.sh exists
          if [ ! -f "test-router.sh" ]; then
            echo "‚ùå test-router.sh not found in root directory"
            exit 1
          fi
          
          # Test that it can show help
          if ! ./test-router.sh --help 2>&1 | grep -q "Test Names:"; then
            echo "‚ùå test-router.sh --help not working correctly"
            exit 1
          fi
          
          # Discover available tests dynamically
          echo "üîç Discovering available tests in test-router.sh..."
          available_tests=($(./test-router.sh --help 2>&1 | grep -A 20 "Test Names:" | grep -E "^  [a-zA-Z-]+" | sed 's/^  //' | sed 's/ .*//' | tr '\n' ' '))
          
          if [ ${#available_tests[@]} -eq 0 ]; then
            echo "‚ùå No tests found in test-router.sh help output"
            exit 1
          fi
          
          echo "‚úÖ Found ${#available_tests[@]} available tests:"
          for test in "${available_tests[@]}"; do
            echo "  - $test"
          done
          
          # Check for essential tests
          essential_tests=("health" "products" "status" "all")
          for test in "${essential_tests[@]}"; do
            if [[ ! " ${available_tests[@]} " =~ " ${test} " ]]; then
              echo "‚ùå Essential test not found: $test"
              exit 1
            fi
          done
          
          echo "‚úÖ test-router.sh functionality working correctly"
          
          # Test that build validation script exists and has help
          echo "Testing build validation script..."
          
          # Check if build-validate.sh exists
          if [ ! -f "scripts/build-validate.sh" ]; then
            echo "‚ùå build-validate.sh not found in scripts directory"
            exit 1
          fi
          
          # Test that it has help functionality
          if ! ./scripts/build-validate.sh --help 2>&1 | grep -q "Usage:"; then
            echo "‚ùå build-validate.sh --help not working correctly"
            exit 1
          fi
          
          echo "‚úÖ build-validate.sh exists and has help functionality"
          
          # Test all scripts that have --help functionality
          echo "Testing script help functionality..."
          echo "üîç Checking which scripts support --help..."
          
          help_scripts=()
          for script in "${user_scripts[@]}"; do
            if ./"$script" --help 2>&1 | grep -q "Usage:\|Options:"; then
              help_scripts+=("$script")
            fi
          done
          
          for script in "${internal_scripts[@]}"; do
            if ./"scripts/$script" --help 2>&1 | grep -q "Usage:\|Options:"; then
              help_scripts+=("scripts/$script")
            fi
          done
          
          if [ ${#help_scripts[@]} -gt 0 ]; then
            echo "‚úÖ Found ${#help_scripts[@]} scripts with help functionality:"
            for script in "${help_scripts[@]}"; do
              echo "  - $script"
            done
          else
            echo "‚ö†Ô∏è  No scripts found with help functionality"
          fi
          
          # Test that documentation structure is correct
          echo "Testing documentation structure..."
          
          # Check that README.md exists and points to SETUP.md
          if ! grep -q "SETUP.md" README.md; then
            echo "‚ùå README.md missing reference to SETUP.md"
            exit 1
          fi
          
          # Check that SETUP.md exists and contains commands
          if [ ! -f "SETUP.md" ]; then
            echo "‚ùå SETUP.md not found"
            exit 1
          fi
          
          # Check that ARCHITECTURE.md exists
          if [ ! -f "ARCHITECTURE.md" ]; then
            echo "‚ùå ARCHITECTURE.md not found"
            exit 1
          fi
          
          # Check that README-K8S.md is deleted
          if [ -f "README-K8S.md" ]; then
            echo "‚ùå README-K8S.md still exists (should be deleted)"
            exit 1
          fi
          
          echo "‚úÖ Documentation structure is correct"
          
          # Test that cleanup-k8s.sh provides helpful output
          echo "Testing cleanup-k8s.sh output..."
          
          # Test that it mentions minikube is still running
          if ! ./cleanup-k8s.sh 2>&1 | grep -q "Minikube is still running"; then
            echo "‚ùå cleanup-k8s.sh missing minikube warning"
            exit 1
          fi
          
          # Test that it mentions kill-minikube.sh
          if ! ./cleanup-k8s.sh 2>&1 | grep -q "kill-minikube.sh"; then
            echo "‚ùå cleanup-k8s.sh missing kill-minikube.sh reference"
            exit 1
          fi
          
          echo "‚úÖ cleanup-k8s.sh provides helpful output"

  test-k8s-yaml:
    name: Test Kubernetes YAML Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5.0.0

      - name: Install yamllint
        run: |
          pip install yamllint

      - name: Validate YAML files
        run: |
          # Test all YAML files in k8s directory
          if [ -d "k8s" ]; then
            for yaml_file in k8s/*.yaml; do
              if [ -f "$yaml_file" ]; then
                echo "Validating YAML format: $yaml_file"
                yamllint "$yaml_file" || exit 1
              fi
            done
          fi

          # Test GitHub Actions workflows
          for workflow in .github/workflows/*.yaml; do
            if [ -f "$workflow" ]; then
              echo "Validating workflow: $workflow"
              yamllint "$workflow" || exit 1
            fi
          done

          echo "‚úÖ All YAML files have valid format"

      - name: Test Kubernetes manifest structure
        run: |
          # Basic structure validation without kubectl
          echo "Testing Kubernetes manifest structure..."

          # Check if required files exist
          required_files=("k8s/namespace.yaml" \
            "k8s/subgraphs-deployment-clusterip.yaml" \
            "k8s/router-deployment-clusterip.yaml" \
            "k8s/ingress.yaml")

          for file in "${required_files[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Required Kubernetes manifest missing: $file"
              exit 1
            fi
            echo "‚úÖ Found: $file"
          done

          # Check for basic Kubernetes resource types
          for file in k8s/*.yaml; do
            if [ -f "$file" ]; then
              echo "Checking $file for Kubernetes resource types..."
              if ! grep -q "kind:" "$file"; then
                echo "‚ùå No 'kind:' field found in $file"
                exit 1
              fi
              if ! grep -q "apiVersion:" "$file"; then
                echo "‚ùå No 'apiVersion:' field found in $file"
                exit 1
              fi
            fi
          done

          echo "‚úÖ All Kubernetes manifests have basic structure"
